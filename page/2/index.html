<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jieling">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Jieling">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jieling Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jieling</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jieling</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/LC-138-Copy-List-with-Random-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/LC-138-Copy-List-with-Random-Pointer/" class="post-title-link" itemprop="url">LC#138 Copy List with Random Pointer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-07 15:53:32 / Modified: 16:41:09" itemprop="dateCreated datePublished" datetime="2020-06-07T15:53:32-07:00">2020-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先区别两个重要概念：<code>shallow copy</code> &amp; <code>deep copy</code></p>
<ul>
<li>Shallow copy: A shallow copy can be made by simply copying the reference.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        data = values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/07/LC-138-Copy-List-with-Random-Pointer/deep_v1.gif" alt=""></p>
<ul>
<li>Deep copy: A deep copy means actually creating a new array and copying over the values.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[values.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = values[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/07/LC-138-Copy-List-with-Random-Pointer/deep_v3.gif" alt=""></p>
<p>总而言之，deep copy 是需要实打实地遍历到所有的节点。这种遍历通常是两种方式：递归和非递归，直接看代码就能很清晰。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;K, V&gt; = &lt;old nodes, new nodes&gt;</span></span><br><span class="line">    HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(head);</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">        visited.put(head, newNode);</span><br><span class="line">        newNode.next = copyRandomList(head.next);</span><br><span class="line">        newNode.random = copyRandomList(head.random);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;K, V&gt; = &lt;old nodes, new nodes&gt;</span></span><br><span class="line">    HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node old = head;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(old.val);</span><br><span class="line">        visited.put(old, newNode);</span><br><span class="line">        <span class="keyword">while</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.random = clone(old.random);</span><br><span class="line">            newNode.next = clone(old.next);</span><br><span class="line">            old = old.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> visited.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">clone</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(node)) &#123;</span><br><span class="line">            visited.put(node, <span class="keyword">new</span> Node(node.val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/LC-315-Count-of-Smaller-Numbers-After-Self/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/LC-315-Count-of-Smaller-Numbers-After-Self/" class="post-title-link" itemprop="url">LC#315 Count of Smaller Numbers After Self</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-31 15:36:16 / Modified: 16:31:28" itemprop="dateCreated datePublished" datetime="2020-05-31T15:36:16-07:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
</blockquote>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0]</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>暴力解很轻松，循环两遍就可以了，时间复杂度是 O(N<sup>2</sup>)</p>
<p>但是这道题既然出现在这里目标肯定就不是暴力解。题目中提到了所有在这个数之后比它小的数，可以联想到用二叉树的思想。建立一个二叉树，那么所有在这个节点左边的数不就都是小于这个数的了吗？平均的时间复杂度就能降到 O(NlogN)。但是这会带来另一个问题，如果按照正常的顺序建立二叉树，最后怎么按照原始数组的顺序来遍历并生成新的数组呢？ </p>
<p>所以我们需要倒序建立二叉树。为什么倒序就能成立呢？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: [4 1 8 2 3 6 7 5]</span><br></pre></td></tr></table></figure>

<p>从最后一个数字 5 开始，我们能组建出下面这棵二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">    3     7</span><br><span class="line">   &#x2F; \   &#x2F; \</span><br><span class="line">  2   4 6   8</span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>那么可以看到，对于每一个数，我们要的结果（所有在它后面且比它小的数）都只跟它插入时到底向右走了几次，以及该节点有多少个左节点有关，比如最后插入的 4 ，在插入时的经历如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 -&gt; go left, no effect for 4 </span><br><span class="line">  -&gt; 3 -&gt; go right </span><br><span class="line">  -&gt; get to 4, the result should be 2 + 1 &#x3D; 3</span><br><span class="line">     3 is the only smaller element met by 4, plus 1, and 3 has two smaller elements, plus 2</span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val, leftSum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            val = v;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Integer[] count = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> Arrays.asList(count);</span><br><span class="line">        </span><br><span class="line">        Node root = <span class="keyword">new</span> Node(nums[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            count[i] = insert(root, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return the count of all smaller elements of this number</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(Node node, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.val != num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; node.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) node.left = <span class="keyword">new</span> Node(num);</span><br><span class="line">                node.leftSum ++;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += node.leftSum + node.count;</span><br><span class="line">                <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) node.right = <span class="keyword">new</span> Node(num);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.count++;</span><br><span class="line">        <span class="keyword">return</span> sum + node.leftSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>但是这个算法并不是最好的，因为无法保证能建立出一个平衡二叉树，受到输入数组的影响较大，所以严格来讲时间复杂度分析为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best case O(NlogN), worse case O(N*N)</span><br></pre></td></tr></table></figure>
<p>讨论区给了 <a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76584/Mergesort-solution" target="_blank" rel="noopener">另一种解法</a> ，由 merge sort 发展而来，可以做到严格的 O(NlogN)。是更好的解法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/LC-1074-Number-of-Submatrices-That-Sum-to-Target/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/LC-1074-Number-of-Submatrices-That-Sum-to-Target/" class="post-title-link" itemprop="url">LC#1074 Number of Submatrices That Sum to Target</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-24 12:58:40 / Modified: 14:02:36" itemprop="dateCreated datePublished" datetime="2020-05-24T12:58:40-07:00">2020-05-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>Given a <code>matrix</code> and a <code>target</code>, return the number of non-empty submatrices that sum to <code>target</code>.<br>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.<br>Two submatrices <code>(x1, y1, x2, y2)</code> and <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> are different if they have some coordinate that is different: for example, if <code>x1 != x1&#39;</code>.</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题属于 <a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LC#560</a> 的二维扩展版，可以用同样的方法来解决。一维版本中涉及到了一个很常见也很有用的方法：<a href="https://en.wikipedia.org/wiki/Prefix_sum" target="_blank" rel="noopener">prefix sum</a>，通过计算 <code>sum[j] - sum[i] (j &gt; i)</code> 就可以得到处于 <code>i</code> 和 <code>j</code> 之间的数字的和是多少。</p>
<p>一维版本的代码如下，时间复杂度为 O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; sumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    sumMap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Calculate prefix sum</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="comment">// If sum[j] - sum[i] = k, </span></span><br><span class="line">        <span class="comment">// indicates the sum of elements lying between i and j is k</span></span><br><span class="line">        <span class="keyword">if</span> (sumMap.containsKey(sum - k)) &#123;</span><br><span class="line">            count += sumMap.get(sum - k);</span><br><span class="line">        &#125;</span><br><span class="line">        sumMap.put(sum, sumMap.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题可以用相同的方法来做，只是需要处理两个问题：</p>
<ol>
<li>怎么计算 prefix sum matrix ？</li>
</ol>
<p>这张图表示的很清楚。</p>
<p><img src="/2020/05/24/LC-1074-Number-of-Submatrices-That-Sum-to-Target/2d_prefix.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefixSum[i][j] = prefixSum[i - <span class="number">1</span>][j] + prefixSum[i][j - <span class="number">1</span>] - prefixSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>怎么对矩阵进行遍历？</li>
</ol>
<p>确定两行（也可以确定两列），对列（或行）进行遍历。</p>
<p><img src="/2020/05/24/LC-1074-Number-of-Submatrices-That-Sum-to-Target/all_matrices3.png" alt=""></p>
<p>注意在遍历过程中需要再计算一下对于当前两行一列的 prefix sum 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = prefixSum[r2][col] - prefixSum[r1 - <span class="number">1</span>][col];</span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = matrix.length, c = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// Calculate the prefix sum matrix</span></span><br><span class="line">    <span class="keyword">int</span>[][] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[r + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; r + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; c + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            prefixSum[i][j] = </span><br><span class="line">                prefixSum[i - <span class="number">1</span>][j] + </span><br><span class="line">                prefixSum[i][j - <span class="number">1</span>] - </span><br><span class="line">                prefixSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + </span><br><span class="line">                matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, sum;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// Fix two rows and reduce to 1D problem</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r1 = <span class="number">1</span>; r1 &lt; r + <span class="number">1</span>; r1++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r2 = r1; r2 &lt; r + <span class="number">1</span>; r2++) &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">            map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// Almost the same with 1D solution</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; c + <span class="number">1</span>; col++) &#123;</span><br><span class="line">                sum = prefixSum[r2][col] - prefixSum[r1 - <span class="number">1</span>][col];</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(sum - target)) &#123;</span><br><span class="line">                    count += map.get(sum - target);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(R<sup>2</sup>C)<br>空间复杂度：O(RC)</p>
<p>（图片来源：LeetCode 1074 Solution）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/LC-679-24-Game/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/22/LC-679-24-Game/" class="post-title-link" itemprop="url">LC#679 24 Game</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-22 18:32:53" itemprop="dateCreated datePublished" datetime="2020-05-22T18:32:53-07:00">2020-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-24 14:06:17" itemprop="dateModified" datetime="2020-05-24T14:06:17-07:00">2020-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>You have 4 cards each containing a number from 1 to 9. You need to judge whether they could operated through <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>, <code>(</code>, <code>)</code> to get the value of 24.</p>
</blockquote>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 1, 8, 7]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>显然这道题需要穷举出所有的可能性，也就是决策树的遍历过程，用回溯算法，框架在 <a href="https://jielingwang.github.io/2020/05/22/Backtracking-Template/" target="_blank" rel="noopener">这里</a>。</p>
<p>基于这个框架，这道题需要考虑几个问题：</p>
<ul>
<li>track 和 options 分别是什么？</li>
</ul>
<p>这道题的 track 和 options 其实可以综合成一个数组。姑且用 options 来表示。每次做选择之前，options 代表当前可以选择的数字，做选择之后，两个数字合成一个数字，重新放到 options 中作为下一轮的备选项。</p>
<ul>
<li>结束条件？</li>
</ul>
<p>因为 options 在不断更新，因此当 options 只剩一个数字时结束，如果该数字为 24 就可以返回 true，否则返回 false.</p>
<ul>
<li>四则运算怎么处理？</li>
</ul>
<p>因为每次新生成的数字都跟运算有关，所以每次做选择之后都需要生成 next 列表来记录所有可能的运算结果，再用 for 循环来遍历。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> eps = <span class="number">0.001</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; options = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums) options.add((<span class="keyword">double</span>) n);</span><br><span class="line">        <span class="keyword">return</span> backtrack(options);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(List&lt;Double&gt; options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (options.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(options.get(<span class="number">0</span>) - <span class="number">24</span>) &lt; eps) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; options.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// Generate next list</span></span><br><span class="line">                List&lt;Double&gt; next = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                Double p1 = options.get(i), p2 = options.get(j);</span><br><span class="line">                next.addAll(Arrays.asList(p1 + p2, p1 - p2, p2 - p1, p1 * p2));</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(p2) &gt; eps)  next.add(p1/p2);</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(p1) &gt; eps)  next.add(p2/p1);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Pre-order operations</span></span><br><span class="line">                options.remove(i);</span><br><span class="line">                options.remove(j);</span><br><span class="line">                <span class="keyword">for</span> (Double n : next) &#123;</span><br><span class="line">                    options.add(n);</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(options)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// Post-order operations</span></span><br><span class="line">                    options.remove(options.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                options.add(j, p2);</span><br><span class="line">                options.add(i, p1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/Backtracking-Template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/22/Backtracking-Template/" class="post-title-link" itemprop="url">Backtracking Template</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-22 17:53:09" itemprop="dateCreated datePublished" datetime="2020-05-22T17:53:09-07:00">2020-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-02 18:10:47" itemprop="dateModified" datetime="2020-07-02T18:10:47-07:00">2020-07-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据 <a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.md" target="_blank" rel="noopener">这篇文章</a> 整理而成，仅供自己学习备忘。</p>
<p>解决回溯问题，其实就是一个决策树的遍历过程。这里有三个重要概念：</p>
<ul>
<li>路径：已经做出的选择</li>
<li>选择列表：当前可以做的选择</li>
<li>结束条件：表示到达决策树的底层，无法再做选择的时刻</li>
</ul>
<p>可以把路径和选择列表看作决策树上每个节点的属性。<code>backtrack</code> 函数就像指针，在这棵树上游走，所以进入一个节点和离开一个节点时都要正确维护这个节点的属性，所以在递归前需要“做选择”，递归后需要“撤销选择”，相当于遍历一棵树时的前序操作和后序操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(track, options)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> meet end condition:</span><br><span class="line">        result.add(track)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> options:</span><br><span class="line">        remove this op <span class="keyword">from</span> options</span><br><span class="line">        track.add(op)</span><br><span class="line">        backtrack(track, options)</span><br><span class="line">        track.remove(op)</span><br><span class="line">        options.add(op)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/LC-752-Open-the-Lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/LC-752-Open-the-Lock/" class="post-title-link" itemprop="url">LC#752 Open the Lock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-21 16:36:23 / Modified: 17:32:14" itemprop="dateCreated datePublished" datetime="2020-05-21T16:36:23-07:00">2020-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个带四个拨轮的转盘锁，每个拨轮都有 10 个数字（0 ~ 9）。每次旋转都只能旋转一个拨轮的一位数字。初始数字为 <code>&#39;0000&#39;</code>。<code>deadend</code> 代表一组死亡数字，拨轮不能出现该列表中的元素。<code>target</code> 代表终点。求最小旋转次数，没办法的话返回 -1。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>本质是个什么问题呢？</li>
</ul>
<p>先不考虑 <code>deadend</code>。每次只能拨一个轮子的一位数字，一共有四个轮子，一个轮子可以向上拨也可以向下拨。所以对于每个字符串，都有 8 个邻居。寻找起点到终点的最短路径，所以是个 BFS 的问题。</p>
<ul>
<li>遇到 <code>deadend</code> 怎么办？</li>
</ul>
<p>可以加入 <code>queue</code> 中，但是不进行扩展，直接跳过。</p>
<ul>
<li>怎么生成转盘向下或者向上拨之后的新字符串呢？</li>
</ul>
<p>对于非边界数字，可以用 <code>(char) c +/- 1</code> 直接生成临近数字，对于边界数字直接赋值即可。最后用 <code>new String(char[])</code> 生成新字符串。</p>
<h2 id="基于-BFS-框架的代码实现"><a href="#基于-BFS-框架的代码实现" class="headerlink" title="基于 BFS 框架的代码实现"></a>基于 BFS 框架的代码实现</h2><p>框架在 <a href="https://jielingwang.github.io/2020/05/21/BFS-Template/" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use to deal with the deadends issue</span></span><br><span class="line">    Set&lt;String&gt; deadset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String d : deadends) deadset.add(d);</span><br><span class="line">    </span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Put the start node into queue</span></span><br><span class="line">    queue.offer(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="comment">// Need to record the visited paths</span></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(<span class="string">"0000"</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">            String curr = queue.poll();</span><br><span class="line">            <span class="comment">// Deal with deadends issue</span></span><br><span class="line">            <span class="keyword">if</span> (deadset.contains(curr)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Get to the target</span></span><br><span class="line">            <span class="keyword">if</span> (curr.equals(target)) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// Add all adjacents into queue</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                String u = up(curr, i);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(u)) &#123;</span><br><span class="line">                    visited.add(u);</span><br><span class="line">                    queue.offer(u);</span><br><span class="line">                &#125;</span><br><span class="line">                String d = down(curr, i);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(d)) &#123;</span><br><span class="line">                    visited.add(d);</span><br><span class="line">                    queue.offer(d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update steps</span></span><br><span class="line">        step ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper functions</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">up</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (c[i] == <span class="string">'9'</span>) &#123;</span><br><span class="line">        c[i] = <span class="string">'0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">down</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (c[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        c[i] = <span class="string">'9'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c[i] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/BFS-Template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/BFS-Template/" class="post-title-link" itemprop="url">BFS Template</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-21 16:11:12 / Modified: 17:22:36" itemprop="dateCreated datePublished" datetime="2020-05-21T16:11:12-07:00">2020-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据 <a href="https://mp.weixin.qq.com/s/WH_XGm1-w5882PnenymZ7g" target="_blank" rel="noopener">这篇文章</a> 整理而成，仅供自己学习备忘。</p>
<p>BFS 核心思想为把一个问题抽象成图，从一个点开始向四周扩散，寻找起点到终点的最短路径。常见例子为：</p>
<ul>
<li>走迷宫，有的格子不能走，求从起点到终点最短路径</li>
<li>两个单词，通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少替换几次？</li>
<li>连连看游戏，两个方块消除的条件不仅是图案相同，还要保证两个方块之间的最短连线不能多于两个拐点，那么怎么判断最短连线有几个拐点呢？</li>
</ul>
<ol start="0">
<li>框架</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">            Node curr = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr is target) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Node n : curr.adj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n not in visited) &#123;</span><br><span class="line">                    q.offer(n);</span><br><span class="line">                    visited.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么 BFS 可以找到最短路径？DFS 可以吗？（遇到过的面试题）</li>
</ul>
<p>因为 BFS 的逻辑是：step 每增加一次，队列中所有节点都前进了一步，这就能保证第一次到达终点的时候，走的步数是最少的。DFS 当然也可以找到最短路径，但是 DFS 是靠递归的堆栈记录走过的路径，如果想要找最短，肯定是要把所有路径都遍历完才能对比出最短路径有多长，所以时间复杂度相比 BFS 会高很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/Binary-Search-Templates/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/Binary-Search-Templates/" class="post-title-link" itemprop="url">Binary Search Templates</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-11 20:37:11 / Modified: 21:23:52" itemprop="dateCreated datePublished" datetime="2020-05-11T20:37:11-07:00">2020-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">这篇文章</a>整理而成，仅供自己学习备忘。</p>
<ol start="0">
<li>框架</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binSrch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">int</span> right = ...</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：把所有情况用 else if 写清楚，有助于展现所有的细节。</p>
<ol>
<li>查找一个数，存在，返回索引，不存在，返回 -1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binSrch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意几个问题：</p>
<ul>
<li>搜索范围</li>
</ul>
<p>该算法中 <code>right</code> 初始化为 <code>nums.length - 1</code>，相当于查找范围为两端都闭区间 <code>[left, right]</code>，因此如果初始化为 <code>nums.length</code>，则意味着查找范围为左闭右开区间 <code>[left, right)</code>。</p>
<ul>
<li>终止条件</li>
</ul>
<p>while 循环应当在什么时候终止呢？应当在搜索区间为空的时候终止。如果将该算法的终止条件改为 <code>left &lt; right</code>，即当 <code>left == right</code> 时终止，此时搜索区间为 <code>[left, left]</code>，仍然有值，这个值就会被落下。</p>
<ul>
<li>区间更新</li>
</ul>
<p>该算法中搜索区间为闭区间 <code>[left, right]</code>，因此当判断 <code>mid</code> 已经不是 <code>target</code> 了之后，自然应该把 <code>left</code> 更新为 <code>mid + 1</code> 或者把 <code>right</code> 更新为 <code>mid - 1</code>。</p>
<ol start="2">
<li>寻找左侧边界</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binSrch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">int</span> right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依然是以下几个问题：</p>
<ul>
<li>搜索范围</li>
</ul>
<p>该算法中 <code>right</code> 初始化为 <code>nums.length</code>，因此查找范围为左闭右开区间 <code>[left, right)</code>。</p>
<ul>
<li>终止条件</li>
</ul>
<p>该算法的终止条件为 <code>left &lt; right</code>，即当 <code>left == right</code> 时终止，此时搜索区间为 <code>[left, left)</code>，确实为空，因此成立。</p>
<ul>
<li>区间更新</li>
</ul>
<p>因为此时搜索区间为左闭右开区间 <code>[left, right)</code>，因此右边界的更新始终应为 <code>mid</code>，此时 <code>mid</code> 不包含在搜索区间内。</p>
<ul>
<li>什么时候返回 -1</li>
</ul>
<p>如果目标不存在，最后 <code>left</code> 会更新到 <code>0</code> 或者 <code>nums.length</code>，因此对这两种情况做讨论进行输出即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>寻找右侧边界</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binSrch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">int</span> right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前讨论过的几个问题都比较好理解了，这里只有两个问题：</p>
<ul>
<li>为什么最后返回的是 <code>left - 1</code> ？</li>
</ul>
<p>因为当 <code>nums[mid] == target</code> 的时候，<code>left</code> 更新为 <code>mid + 1</code>，最后跳出循环时已经不再等于目标了，<code>nums[left - 1]</code> 才是目标。</p>
<ul>
<li>怎么返回 -1 ？</li>
</ul>
<p><code>left</code> 取值范围依然是 <code>[0, nums.length]</code>，因此对两种情况讨论即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? left - <span class="number">1</span> : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/LC-31-Next-Permutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/LC-31-Next-Permutation/" class="post-title-link" itemprop="url">LC#31 Next Permutation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-10 16:42:35 / Modified: 17:30:06" itemprop="dateCreated datePublished" datetime="2020-05-10T16:42:35-07:00">2020-05-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一串数字，输出下一个更大的排列。如果无法找到更大的排列，则输出最小的排列。</p>
<p>Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 -&gt; 1,3,2</span><br><span class="line">3,2,1 -&gt; 1,2,3</span><br><span class="line">1,1,5 -&gt; 1,5,1</span><br></pre></td></tr></table></figure>

<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>首先理解题意中的两个重要部分：</p>
<ul>
<li>什么情况下“无法找到更大的排列”呢？</li>
</ul>
<p>对于一串数字，最大的排列是全降序排列，最小的排列是全升序排列。因此根据题意，当一串数字全降序排列时，无法找到更大的排列，我们需要输出升序排列。</p>
<ul>
<li>如何能找出下一个更大的排列呢？</li>
</ul>
<p>注意不是最大的排列，也不是其他更大的排列，而是紧挨着现有排列的，下一个，更大的排列。</p>
<p>以排列 <code>[1 9 8 4 7 6 5 3 1]</code> 为例：</p>
<p>首先我们要找到可以进行操作的部分。在这个例子中我们发现子序列 <code>[7 6 5 3 1]</code> 已经是降序排列，这一部分已经无法组成更大的排列了。也就是说，<code>[4 7 6 5 3 1]</code> 已经是 4 开头的最后一个排列，那么下一个排列怎么来呢？一定是在这个子序列中，找到离 4 最近的下一个数字，也就是 5 作为新的开头，剩下的数字做升序排列。也就是以 5 开头的最小排列。所以我们找到下一个更大的排列是 <code>[5 1 3 4 6 7]</code>，加上前面的元素，可以得到输出应为 <code>[1 9 8 5 1 3 4 6 7]</code></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现时分为四步：</p>
<ol>
<li>从数组最右端开始，找到第一个不属于降序排列的数字 i</li>
<li>找到降序排列中刚好稍大于 i 的数字 j</li>
<li>交换数字 i 和 j</li>
<li>对 i 之后的所有数字做反序，即得到升序排列</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; nums.length &amp;&amp; nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">            reverse(nums, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        i ++;</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/LC-1249-Minimum-Remove-to-Make-Valid-Parentheses/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jieling Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jieling">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/LC-1249-Minimum-Remove-to-Make-Valid-Parentheses/" class="post-title-link" itemprop="url">LC#1249 Minimum Remove to Make Valid Parentheses</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-03 15:00:18 / Modified: 15:49:55" itemprop="dateCreated datePublished" datetime="2020-05-03T15:00:18-07:00">2020-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给一个含有 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 以及小写字母的字符串，去掉最少个数的 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code> 使括号匹配，返回任意匹配的字符串。</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;lee(t(c)o)de)&quot;</span><br><span class="line">output: &quot;leet(t(c)o)de&quot;</span><br><span class="line">Explanation: &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.</span><br></pre></td></tr></table></figure>

<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这是一道很常见的面试题，基本思路就是用 stack，遇到 <code>&#39;(&#39;</code> 就把它推进去（或者把对应的下标推进去），遇到 <code>&#39;)&#39;</code> 就把 stack 里的元素弹出来一个。如果遇到 <code>&#39;)&#39;</code> 时发现 stack 为空，就说明这个括号是多余的；如果所有字符都遍历结束 stack 却依然不为空，就意味着 stack 里的 <code>&#39;(&#39;</code> 都是多余的。</p>
<p>补充两点：</p>
<ul>
<li>在 Java 中实现 Stack 的常用结构为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack &#x3D; new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">stack.push(1);</span><br><span class="line">stack.pop();</span><br><span class="line">stack.peek();</span><br></pre></td></tr></table></figure>
<p>这在官方文档中有说明：</p>
<blockquote>
<p>A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class.</p>
</blockquote>
<ul>
<li>实现 Queue 的常用结构为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">queue.offer(1);</span><br><span class="line">queue.poll();</span><br><span class="line">queue.peek();</span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>具体实现分为两步：</p>
<ul>
<li>判断并记录不合法的括号位置</li>
<li>用 StringBuilder 生成新的字符串</li>
</ul>
<p>Time Complexity: O(N)<br>Space Complexity: O(N)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Set&lt;Integer&gt; removeIdx = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// Find all invalid ')'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                removeIdx.add(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// All the '(' left in stack are invalid</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        removeIdx.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Build new string</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!removeIdx.contains(i)) &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tricky-Part"><a href="#Tricky-Part" class="headerlink" title="Tricky Part"></a>Tricky Part</h2><p>在讨论中看到有一种用 placeholder 处理的，十分巧妙。先把整个字符串都转成 StringBuilder，再将其中不合法的括号用特殊字符标记（比如 <code>&#39;*&#39;</code> ），最后用 removeAll 函数去掉所有的 <code>&#39;*&#39;</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// Find all invalid ')' and mark as '*'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.setCharAt(i, <span class="string">'*'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mark all '(' as '*'</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        sb.setCharAt(stack.pop(), <span class="string">'*'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().replaceAll(<span class="string">"\\*"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jieling Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jieling Wang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
